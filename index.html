<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ZN1 / ZN2 PID Chase</title>
  <style>
    #panel {
     
      left: 12px;
      top: 12px;
  
      display: flex;
      flex-direction: column;
      justify-content: center;
      background: rgba(255,255,255,0.92);
      border: 1px solid #ddd;
      border-radius: 10px;
      padding: 10px 12px;
      font-family: Arial, sans-serif;
      font-size: 13px;
      width: 30vw;
      height: 100%; ;
    }
    #panel label { display:block; margin-top: 6px; }
    #panel select { width: 100%; padding: 6px; margin-top: 4px; }
    #panel input { width: 100%; padding: 6px; margin-top: 4px; box-sizing: border-box; }
    #panel button { margin-top: 8px; width: 100%; padding: 8px; cursor: pointer; }
    #log { margin-top: 8px; white-space: pre; font-family: ui-monospace, Menlo, Consolas, monospace; font-size: 12px; }
  </style>
</head>
<body>
  <div id="panel">
    <label>Método</label>
    <select id="method">
      <option value="ZN2">ZN1 (Curva de Reação)</option>
      <option value="ZN1">ZN2 (Ku/Pu)</option>
    </select>

    <label>Ku (ZN2)</label>
    <input id="Ku" type="number" step="0.1" value="50" />

    <label>Pu (ZN2) (s)</label>
    <input id="Pu" type="number" step="0.01" value="1.0" />

    <label>Kx (somente ZN1, laço externo posição→vref)</label>
    <input id="Kx" type="number" step="0.1" value="2.0" />

    <button id="apply">Aplicar método</button>
    <div id="log"></div>
  </div>

  <script>
    // ---------- util ----------
    function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }

    // ---------- visual ----------
    function createDisk(color) {
      const d = document.createElement("div");
      d.style.position = "fixed";
      d.style.width = "30px";
      d.style.height = "30px";
      d.style.borderRadius = "50%";
      d.style.pointerEvents = "none";
      d.style.zIndex = "9999";
      d.style.backgroundColor = color;
      document.body.appendChild(d);
      return d;
    }

    const blue = createDisk("blue");
    const red  = createDisk("red");

    // ---------- referência (mouse) ----------
    let xf = 150, yf = 150;
    document.addEventListener("mousemove", (e) => {
      xf = e.clientX;
      yf = e.clientY;
      red.style.left = (xf - 15) + "px";
      red.style.top  = (yf - 15) + "px";
    });

    // ---------- planta (equivalente ao MATLAB) ----------
    // tau*a_dot + a = u
    // v_dot = a - b*v
    // x_dot = v
    const b   = 2.0;
    const tau = 0.05;

    // estado do sistema (posição)
    let x = 150, y = 150;
    let vx = 0, vy = 0;
    let axPlant = 0, ayPlant = 0;

    // ---------- tempo ----------
    const dt = 0.01; // 10 ms

    // ---------- limites ----------
    const uMax = 5000;
    const iMax = 2000;
    const vRefMax = 1200;
    const deadband = 0.8;

    // =========================
    // 1) ZN1 (Ku/Pu) -> PID direto na posição (como seu código original)
    // =========================
    function computePID_ZN1({ Ku, Pu }) {
      const Kp = 0.6 * Ku;
      const Ti = 0.5 * Pu;
      const Td = 0.125 * Pu;
      const Ki = Kp / Ti;
      const Kd = Kp * Td;
      return { Kp, Ki, Kd, meta: { Ku, Pu, Ti, Td } };
    }

    // =========================
    // 2) ZN2 (Curva de reação) -> aplica na planta de VELOCIDADE (u->v)
    // Gv(s) = 1/((tau s + 1)(s + b))
    // Estimativa K,L,T via 28.3% e 63.2% do degrau em malha aberta
    // =========================
    function simulateOpenLoopStepVelocity({ Du = 1, tEnd = 5 }) {
      let a = 0, v = 0;
      const N = Math.floor(tEnd / dt) + 1;
      const t = new Array(N);
      const y = new Array(N);

      for (let k = 0; k < N; k++) {
        const tk = k * dt;
        const u = Du;

        // atuador 1ª ordem
        a += (dt / tau) * (u - a);

        // dinâmica velocidade
        v += dt * (a - b * v);

        t[k] = tk;
        y[k] = v;
      }
      return { t, y };
    }

    function estimateKLT_283_632({ t, y, Du }) {
      const y0 = y[0];
      const yss = y[y.length - 1];
      const dy = yss - y0;

      if (Math.abs(dy) < 1e-9) throw new Error("Resposta sem variação suficiente.");

      const K = dy / Du;
      const y28 = y0 + 0.283 * dy;
      const y63 = y0 + 0.632 * dy;

      function interpCross(yTarget) {
        for (let i = 1; i < y.length; i++) {
          const yA = y[i - 1], yB = y[i];
          if ((yA - yTarget) * (yB - yTarget) <= 0) {
            const tA = t[i - 1], tB = t[i];
            const denom = (yB - yA) || 1e-12;
            const alpha = (yTarget - yA) / denom;
            return tA + alpha * (tB - tA);
          }
        }
        return null;
      }

      const t28 = interpCross(y28);
      const t63 = interpCross(y63);
      if (t28 == null || t63 == null) throw new Error("Não achou t28/t63 (aumente tEnd).");

      // t28 = L + 0.333T ; t63 = L + 1.0T
      const T = (t63 - t28) / 0.667;
      let L = t63 - T;

      const Lmin = 5 * dt;
      if (L < Lmin) L = Lmin;

      return { K, L, T, t28, t63 };
    }

    function computePID_ZN2_fromReaction() {
      const Du = 1;
      const { t, y } = simulateOpenLoopStepVelocity({ Du, tEnd: 5 });
      const { K, L, T, t28, t63 } = estimateKLT_283_632({ t, y, Du });

      // ZN2 PID clássico
      const Kp = 1.2 * (T / (K * L));
      const Ti = 2 * L;
      const Td = 0.5 * L;
      const Ki = Kp / Ti;
      const Kd = Kp * Td;

      return { Kp, Ki, Kd, meta: { K, L, T, Ti, Td, t28, t63 } };
    }

    // =========================
    // 3) Simulação: dois modos
    // - ZN1: PID direto em posição (exatamente como o seu)
    // - ZN2: cascata (posição->vref) + PID na velocidade
    // =========================
    let mode = "ZN1";
    let gainsPos = computePID_ZN1({ Ku: 50, Pu: 1.0 }); // usado no ZN1
    let gainsVel = null;                                // usado no ZN2

    // estados do PID (posição ou velocidade)
    let ix = 0, iy = 0;
    let exPrev = 0, eyPrev = 0;

    function resetPIDState() {
      ix = 0; iy = 0;
      exPrev = 0; eyPrev = 0;
    }

    function applyMethod() {
      mode = document.getElementById("method").value;

      if (mode === "ZN1") {
        const Ku = Number(document.getElementById("Ku").value);
        const Pu = Number(document.getElementById("Pu").value);
        gainsPos = computePID_ZN1({ Ku, Pu });
        gainsVel = null;
        resetPIDState();
        log(`Modo: ZN1 (posição)\nKp=${gainsPos.Kp.toFixed(3)} Ki=${gainsPos.Ki.toFixed(3)} Kd=${gainsPos.Kd.toFixed(3)}\nTi=${gainsPos.meta.Ti.toFixed(3)} Td=${gainsPos.meta.Td.toFixed(3)}`);
      } else {
        gainsVel = computePID_ZN2_fromReaction(); // ZN2 no laço interno de velocidade
        resetPIDState();
        const Kx = Number(document.getElementById("Kx").value);
        log(
          `Modo: ZN2 (cascata: posição->velocidade)\n` +
          `PID_vel: Kp=${gainsVel.Kp.toFixed(3)} Ki=${gainsVel.Ki.toFixed(3)} Kd=${gainsVel.Kd.toFixed(3)}\n` +
          `FOPDT(v): K=${gainsVel.meta.K.toFixed(3)} L=${gainsVel.meta.L.toFixed(3)} T=${gainsVel.meta.T.toFixed(3)}\n` +
          `Use Kx=${Kx.toFixed(3)}`
        );
      }
    }

    function log(txt) {
      document.getElementById("log").textContent = txt;
    }

    document.getElementById("apply").addEventListener("click", applyMethod);
    applyMethod(); // inicializa

    // =========================
    // 4) Loop de simulação
    // =========================
    setInterval(() => {
      if (mode === "ZN1") {
        // ----- erro de posição -----
        const ex = xf - x;
        const ey = yf - y;

        // integral
        ix = clamp(ix + ex * dt, -iMax, iMax);
        iy = clamp(iy + ey * dt, -iMax, iMax);

        // derivada
        const dex = (ex - exPrev) / dt;
        const dey = (ey - eyPrev) / dt;
        exPrev = ex; eyPrev = ey;

        // PID -> u
        let ux = gainsPos.Kp * ex + gainsPos.Ki * ix + gainsPos.Kd * dex;
        let uy = gainsPos.Kp * ey + gainsPos.Ki * iy + gainsPos.Kd * dey;

        ux = clamp(ux, -uMax, uMax);
        uy = clamp(uy, -uMax, uMax);

        // planta
        axPlant += (dt / tau) * (ux - axPlant);
        ayPlant += (dt / tau) * (uy - ayPlant);

        vx += dt * (axPlant - b * vx);
        vy += dt * (ayPlant - b * vy);

        x += vx * dt;
        y += vy * dt;

      } else {
        // ===== ZN2 (cascata) =====
        const Kx = Number(document.getElementById("Kx").value);

        // erro de posição
        let ex = xf - x;
        let ey = yf - y;

        if (Math.hypot(ex, ey) < deadband) { ex = 0; ey = 0; }

        // laço externo: vref
        const vRefX = clamp(Kx * ex, -vRefMax, vRefMax);
        const vRefY = clamp(Kx * ey, -vRefMax, vRefMax);

        // erro de velocidade (interno)
        const evx = vRefX - vx;
        const evy = vRefY - vy;

        // integral do erro de velocidade
        ix = clamp(ix + evx * dt, -iMax, iMax);
        iy = clamp(iy + evy * dt, -iMax, iMax);

        // derivada do erro de velocidade
        const devx = (evx - exPrev) / dt;
        const devy = (evy - eyPrev) / dt;
        exPrev = evx; eyPrev = evy;

        // PID_vel -> u
        let ux = gainsVel.Kp * evx + gainsVel.Ki * ix + gainsVel.Kd * devx;
        let uy = gainsVel.Kp * evy + gainsVel.Ki * iy + gainsVel.Kd * devy;

        ux = clamp(ux, -uMax, uMax);
        uy = clamp(uy, -uMax, uMax);

        // planta
        axPlant += (dt / tau) * (ux - axPlant);
        ayPlant += (dt / tau) * (uy - ayPlant);

        vx += dt * (axPlant - b * vx);
        vy += dt * (ayPlant - b * vy);

        x += vx * dt;
        y += vy * dt;
      }

      // render
      blue.style.left = (x - 15) + "px";
      blue.style.top  = (y - 15) + "px";
    }, dt * 1000);
  </script>
</body>
</html>



